apiVersion: v1                    # Define a vers√£o da API Kubernetes usada para este recurso (v1 √© padr√£o para Services)
kind: Service                     # Tipo do objeto que estamos criando (Service, respons√°vel por expor Pods na rede)
metadata:                         # Metadados do recurso (informa√ß√µes de identifica√ß√£o)
  name: flask-service3             # Nome do Service (usado para refer√™ncia no cluster)
spec:                             # Especifica√ß√£o do Service (define como ele ir√° expor os Pods)
  selector:                        # Define quais Pods este Service ir√° alcan√ßar
    app: flask-app                 # Seleciona todos os Pods que possuem a label "app: flask-app"
  ports:                           # Define as portas que o Service ir√° expor
    - protocol: TCP                # Protocolo usado (TCP √© padr√£o para aplica√ß√µes web)
      port: 5000                   # Porta que ser√° exposta pelo Service
      targetPort: 5000             # Porta em que os Pods est√£o escutando (a mesma do container)
  type: LoadBalancer               # Tipo de Service: LoadBalancer cria um IP externo acess√≠vel fora do cluster

# üí° Como rodar este Service em modo declarativo:
# 1. Salve este conte√∫do em um arquivo, por exemplo: service.yaml
# 2. Aplique o arquivo no cluster Kubernetes com:
#       kubectl apply -f service.yaml
# 3. Verifique se o Service foi criado e veja o IP externo:
#       kubectl get services
# 4. Agora voc√™ pode acessar a aplica√ß√£o atrav√©s do IP externo (LoadBalancer) ou
#    testar internamente usando Minikube IP e a porta definida.
#
# üîπ Explica√ß√£o:
# - O Service garante um ponto de acesso est√°vel para os Pods selecionados, mesmo que eles
#   sejam recriados ou escalonados pelo Deployment.
# - LoadBalancer √© usado quando voc√™ precisa de acesso externo; para uso interno, ClusterIP ou NodePort podem ser usados.
